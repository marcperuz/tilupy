# -*- coding: utf-8 -*-

import os

import numpy as np
import tilupy.read

# hv = hn * costh
STATES_OUTPUT = ["h", "hux", "huy"]
"""State variables of the flow available with saval2D.

Implemented states :

    - h : flow thickness (normal to the surface)
    - hux : momentum component in X direction
    - huy : momentum component in Y direction
"""

COMPUTED_OUTPUT = ["u", "hu", "hu2", "hvert", "ux", "uy"]
"""Computed variables of the flow available with saval2D.

Available outputs :

    - u : flow velocity (norm)
    - hu : momentum
    - ux : velocity component in X direction
    - uy : velocity component in Y direction
"""

def extract_saval_ascii(path: str) -> np.ndarray:
    """Extract ascii file data generated by saval2D.

    Parameters
    ----------
    path : str
        Path to the ascii file.

    Returns
    -------
    numpy.ndarray
        Values in the ascii file.
    """
    with open(path, 'r') as f:
        lines = f.readlines()
    start_index = 6
    
    h_str = lines[start_index:]

    h = [list(map(float, line.split())) for line in h_str if line.strip()]
    return np.array(h)


class Results(tilupy.read.Results):
    """Results of saval2D simulations.

    This class is the results class for saval2D. Reading results from saval2D outputs 
    are done in this class.
    
    This class has all the global and quick attributes of the parent class. The quick 
    attributes are only computed if needed and can be deleted to clean memory.
    
    In addition to these attributes, there are those necessary for the operation of 
    reading the saval2D results.
    
    Global attributes:
    ------------------
        _code : str
            Name of the code that generated the result.
        _folder : str
            Path to find code files (like parameters).
        _folder_output :
            Path to find the results of the code.
        _zinit : numpy.ndarray
            Surface elevation of the simulation.
        _tim : list
            Lists of recorded time steps.
        _x : numpy.ndarray
            X-coordinates of the simulation.
        _y : numpy.ndarray
            Y-coordinates of the simulation.
    
    Quick access attributes:
    ------------------------
        _h : tilupy.read.TemporalResults2D
            Fluid height over time.
        _h_max : tilupy.read.TemporalResults0D
            Max fluid hieght over time.
        _u : tilupy.read.TemporalResults2D
            Norm of fluid velocity over time.
        _u_max : tilupy.read.TemporalResults0D
            Max norm of fluid velocity over time.
        _costh : numpy.ndarray
            Value of cos[theta] at any point on the surface.
            
    Specific attributes:
    --------------------
        _simu_inputs : str
            Path to the input folder of saval2D simulation.
        _simu_outputs : str
            Path to the output folder of saval2D simulation.
        _raster : str
            Raster file name.
        _params : dict
            Dictionary storing all simulation parameters.
        _dx : float
            Cell size in the X direction.
        _dy : float
            Cell size in the Y direction.
        _nx : int
            Number of cells in the X direction.
        _ny : int
            Number of cells in the Y direction.
        
    Parameters:
    -----------
    folder : str
        Path to the folder containing the simulation files.
    raster_topo : str
        Topographic raster name.
    """
    def __init__(self, folder, raster_topo="mntsimulation.asc"):
        super().__init__()
        self._code = "saval2D"
        
        self._folder = folder
        self._folder_output = folder
        
        self._simu_inputs = os.path.join(folder, "inputs") if os.path.exists(os.path.join(folder, "inputs")) else None
        self._simu_outputs = os.path.join(folder, "outputs") if os.path.exists(os.path.join(folder, "outputs")) else None
        
        if not raster_topo.endswith(".asc"):
            raster_topo = raster_topo + ".asc"
        self._raster = raster_topo

        self._params = dict()

        if self._simu_inputs is not None:
            self._x, self._y, self._zinit = tilupy.raster.read_ascii(os.path.join(self._simu_inputs, 
                                                                                  self._raster))
        self._nx, self._ny = len(self._x), len(self._y)
        self._dx = self._x[1] - self._x[0]
        self._dy = self._y[1] - self._y[0]

        self._params["nx"] = len(self.x)
        self._params["ny"] = len(self.y)

        # Rheology
        rheol = self.get_rheological_parameters(os.path.join(self._simu_outputs, "log.txt"))
        self._params["tau/rho"] = rheol[0]
        self._params["mu"] = rheol[1]
        self._params["xi"] = rheol[2]

        # Create self._tim
        self._extract_output("X")

        
    def get_rheological_parameters(self, path_to_log: str) -> list[str]:
        """Get rheological parameters of a saval2D simulation.

        Parameters
        ----------
        path_to_log : str
            Path to the log file containing the value of the rheological parameters.

        Returns
        -------
        list[str]
            List of rheological parameters : tau/rho, mu and xi.
        """
        values = None
        with open(path_to_log, "r") as f:
            for line in f:
                line = line.strip()
                try:
                    parts = list(map(float, line.split()))
                    if len(parts) == 3:
                        values = parts
                        break
                except ValueError:
                    continue
        return values
        
    
    def get_times(self, path: str) -> list[float]:
        """Get simulation time steps.

        Parameters
        ----------
        path : str
            Path to the log file.

        Returns
        -------
        list[float]
            List of recorded time steps.
        """
        t_list = []
        with open(path, 'r') as f:
            lines = f.readlines()
        
        start_index = 16
        for line in lines[start_index:]:
            if line.strip() == '':
                continue
            else:
                _, t, _, _, _ = line.split()
                t_list.append(float(t))
        
        return t_list            
    
    
    def _extract_output(self, 
                        name: str, 
                        **kwargs
                        ) -> tilupy.read.TemporalResults2D | tilupy.read.TemporalResults0D | tilupy.read.AbstractResults:
        """Result extraction for saval2D files.

        Parameters
        ----------
        name : str
            Wanted output. Can access to variables in :data:`STATES_OUTPUT` and :data:`COMPUTED_OUTPUT` 

        Returns
        -------
        tilupy.read.TemporalResults2D | tilupy.read.TemporalResults0D | tilupy.read.AbstractResults
            Wanted output. If no output computed, return an object of :class:`tilupy.read.AbstractResults`.
        """
        # Read thicknesses or velocity components
        d = None
        t = None
        notation = None
        
        tim = [0]
        t_list = self.get_times(os.path.join(self._simu_outputs, "log.txt"))
        
        _, _, h_init = tilupy.raster.read_ascii(os.path.join(self._simu_inputs, "zdepsimulation.asc"))
        
        h_list = [h_init]
        
        ux_list = []
        uy_list = []
        u_list = []
        ux_list.append(np.zeros_like(h_init))
        uy_list.append(np.zeros_like(h_init))
        u_list.append(np.zeros_like(h_init))
        
        qx_list = []
        qy_list = []
        q_list = []
        qx_list.append(np.zeros_like(h_init))
        qy_list.append(np.zeros_like(h_init))
        q_list.append(np.zeros_like(h_init))
        
        for T in range(len(t_list)):
            h_t = extract_saval_ascii(os.path.join(self._simu_outputs, f"resuh{T+1}.asc"))
            qu_t = extract_saval_ascii(os.path.join(self._simu_outputs, f"resuqu{T+1}.asc"))
            qv_t = extract_saval_ascii(os.path.join(self._simu_outputs, f"resuqv{T+1}.asc"))

            h_t[h_t<0.0001] = 0
            
            ux_t = np.divide(qu_t, h_t, out=np.zeros_like(qu_t), where=h_t != 0)
            uy_t = np.divide(qv_t, h_t, out=np.zeros_like(qv_t), where=h_t != 0)
            
            u_t = np.sqrt(ux_t**2 + uy_t**2)
            q_t = np.sqrt(qu_t**2 + qv_t**2)
            
            h_list.append(h_t)
            
            ux_list.append(ux_t)
            uy_list.append(uy_t)
            u_list.append(u_t)
            
            qx_list.append(qu_t)
            qy_list.append(qv_t)
            q_list.append(q_t)
            
            tim.append(t_list[T])

        if self._tim is None:
            self._tim = np.array(tim)
    
        available_outputs = {"h": h_list,
                             "u": u_list,
                             "hu": q_list,
                             "ux": ux_list,
                             "uy": uy_list,
                             "hux": qx_list,
                             "huy": qy_list,
                             }

        if name in STATES_OUTPUT:
            d = np.stack(available_outputs[name], axis=-1)
            t = self._tim
        
        if name in COMPUTED_OUTPUT:
            if name == "hu2":
                d = np.stack(available_outputs["hu"], axis=-1) * np.stack(available_outputs["u"], axis=-1)
                t = self._tim
            
            elif name == "hvert":
                if self._costh is None:
                    self._costh = self.compute_costh()
                d = np.stack(available_outputs["h"], axis=-1) / self._costh[:, :, np.newaxis]
                t = self._tim
            else:
                d = np.stack(available_outputs[name], axis=-1)
                t = self._tim
        
        # if name == "ek":
        #     if self._costh is None:
        #             self._costh = self.compute_costh()
            
        #     d = []
        #     for i in range(len(self._tim)):
        #         d.append(np.sum((np.stack(available_outputs["hu"], axis=-1)[:, :, i] * 
        #                          np.stack(available_outputs["u"], axis=-1)[:, :, i] *
        #                          self._dx *
        #                          self._dy)
        #                         / self._costh[:, :]))
        #     d = np.array(d)
        #     t = self._tim
        
        if t is None:
            return tilupy.read.AbstractResults(name, d, notation=notation)

        else:
            if d.ndim == 3:
                return tilupy.read.TemporalResults2D(name, 
                                                     d, 
                                                     t, 
                                                     notation=notation, 
                                                     x=self._x, 
                                                     y=self._y, 
                                                     z=self._zinit)
            if d.ndim == 1:
                return tilupy.read.TemporalResults0D(name, 
                                                     d, 
                                                     t, 
                                                     notation=notation)
        return None


    def _read_from_file(self, *args, **kwargs):
        """Not useful"""
        return "No saval2D file allows output extraction."